package com.mahb.algorithm.stack;

/**
 * @program: algorithm
 * @description: 思路分析：
 *   1： 初始化 两个栈，运算符栈 s1 和 储存中间结果的 栈 s2
 *   2： 从左至右 扫描中缀表达式；
 *   3： 遇到操作数 进行压栈 s 2;
 *   4： 遇到运算符，比较 其 与 运算符 s 1 栈中 运算符的优先级
 *      4-1: 如果运算符栈 s 1 为空，或 栈顶运算符 为 左括号 ( ,则 直接将此 运算符 入栈；
 *      4-2: 否则 ，若优先级 比栈顶运算符 的高，也将运算符 压入栈 s 1；
 *      4-3: 否则， 将 s1 栈顶 运算符弹出 并 压入到 s2 中， 再次转到 ( 4 -1) 与 s 1 中新的 栈顶运算符 相比较
 *   5：遇到括号时：
 *      5-1 : 如果是 左括号 ( , 则直接 压入  s 1;
 *      5-2 : 如果是 右括号 ) , 则依次弹出 s 1 栈顶的运算符， 并压入 s 2  ， 直到遇到左括号为止， 此时将这一对括号丢弃
 *   6： 重复 2-5 步， 直到表达式 的最右边
 *   7： 将 s 1 中剩余的运算符 依次弹出 并压入 s 2
 *   8： 依次弹出 s 2 中的 元素 并输出， 结果的 逆序 即为 中缀表达式 对应的 后缀表达式
 *
 *   如 中缀表达式为： 1 + (( 2+3 ) * 4 ) -5  ==> 后缀表达式 s 2 出栈为：- 5 + * 4 + 3 2 1  => 1 2 3 + 4 * + 5 -
 * @author: Mr.Mahongbin
 * @create: 2019-10-01 23:49
 **/
public class InfixTransformSuffix {

    // 完成 将 一个中缀表达式 转成后缀表达式的 功能
    // 1，1+(2+3)*4)-5 => 转成 1 2 3 + 4 * + 5 -
    // 2，因为 直接 对str 进行操作不方便，因此先将 "1+(2+3)*4)-5" => 中缀的表达式对应的 list
    //  即 "1+(2+3)*4)-5" => ArrayList [1,+,(,(,2,+,3,),*,),-,5]


}
